'''
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. 
'''

# variables and configs we dont want touched

#stores and keeps track of references to every standard library we use
class _InternalPrivateLibReferenceKeeper:
    def __init__(self) -> None:
        import sys
        import os
        import ctypes
        import threading
        import queue
        import atexit
        import time
        self.sysLibReference=sys
        self.osLibReference=os
        self.ctypeLibReference=ctypes
        self.threadingLibReference=threading
        self.queueLibReference=queue
        self.atexitLibReference=atexit
        self.timeLibReference=time

    def getSYS(self):
        return self.sysLibReference
    
    def getOS(self):
        return self.osLibReference
    
    def getCTypes(self):
        return self.ctypeLibReference
    
    def getThreading(self):
        return self.threadingLibReference
    
    def getQueue(self):
        return self.queueLibReference
    
    def getAtExit(self):
        return self.atexitLibReference
    
    def getTime(self):
        return self.timeLibReference
    
_privateInternalReferenceKeeperObjDoNotEdit=_InternalPrivateLibReferenceKeeper()

#getter wrapper functions
def _privateInternalGetSYSRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getSYS()



def _privateInternalGetOSRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getOS()



def _privateInternalGetCTypesRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getCTypes()

def _privateInternalGetThreadingRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getThreading()

def _privateInternalGetQueueRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getQueue()

def _privateInternalGetAtExitRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getAtExit()


def _privateInternalGetTimeRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getTime()


    

    




#handly ln function, very uncomplicated
def ln(number:int=1):
    
    if(type(number)!=int):
        raise ValueError("error: argument must be an integer")
    elif(number<=0):
        raise ValueError("error: argument must be greater than zero")
    elif(number>0):
        print("\n"*(number),end="")
    else:
        raise ValueError("error: argument somehow hit the no match case, even though that should be impossible. \n(what the heck did you feed this poor function?) \nproblem argument value: "+str(number)+" problem argument value's type: "+str(type(number)))




#just here to make people go away
def warning()->str:
    warning="do not edit this file durring runtime, it runs critical backend systems of easy cli, \nand messing with it can have extremely serious consequences, often resulting in crashing \nor unitended behavour. it is strongly encouraged to leave this file alone if you do not\n know what you are doing."
    print(warning)
    return warning




#our base ui header class
class UIHeaderClass:
    def __init__(self,currentScreenName:str|None):
        self.currentScreenName:str|None=currentScreenName
        

    def setCurrentScreenName(self,newName:str):
        self.currentScreenName=newName

    def getCurrentScreenName(self):
        return self.currentScreenName

    def drawUIHeader(self):
        #DO NOT USE FASTCLI FUNCTIONS IN UI HEADER, AS THAT CAN CAUSE RACE CONDITIONS
        pass
#
_currentLoadedUIHeaderDoNotEdit:UIHeaderClass|None=None

class _CheckAnsiCapableHandler:
    def internalCheckAnsiCapable(self)->bool:
        localC=_privateInternalGetCTypesRef()
        localO=_privateInternalGetOSRef()
        localS=_privateInternalGetSYSRef()
        tempAnsiCapable:bool=False
        try:
            if (localO.name == 'nt'):
                if (localS.stdout.isatty()):
                    #enable ansi
                    kernel32 = localC.windll.kernel32
                    handle = kernel32.GetStdHandle(-11)
                    mode = localC.c_uint32()
                    if kernel32.GetConsoleMode(handle, localC.byref(mode)):
                        kernel32.SetConsoleMode(handle, mode.value | 0x0004)
                    #clear
                    tempAnsiCapable=True

            elif(localO.name == 'posix'):
                if localS.stdout.isatty():
                    term = localO.environ.get('TERM', '')
                    if((not term) or (term == 'dumb')):
                        tempAnsiCapable=False
                    else:
                        tempAnsiCapable=True

            else:
                tempAnsiCapable=False
        except:
            tempAnsiCapable=False

        return tempAnsiCapable

        
    def __init__(self)->None:
        #this whole thing just runs that check
        self.ansiCapable:bool=False
        self.ansiCapable=self.internalCheckAnsiCapable()
        if(type(self.ansiCapable)!=bool):
            raise RuntimeError("error: how the heck did this trigger? it should be physically impossible! \nthere should be no way for those variables to not be set at this point! \nwell, hopefully restarting the program can fix it for you.\n "+" type of ansiCapable: "+ str(type(self.ansiCapable))+" value of ansiCapable: "+str(self.ansiCapable))

    def recheckAnsiCapable(self)->None:
        self.ansiCapable=self.internalCheckAnsiCapable()

    
    def getAnsiCapable(self)->bool:
        return self.ansiCapable
        
    
    
_PrivateAnsiCapableHandlerObject=_CheckAnsiCapableHandler()
    


class _ClearHandler:
    def __init__(self) -> None:
        self.localCT=_privateInternalGetCTypesRef()
        self.localSY=_privateInternalGetSYSRef()
        self.localOS=_privateInternalGetOSRef()
        self.clearMode:int=0
        self._clearOperationDispatcher = {
            0: lambda: self._InternalAutoClearConfig(),
            1: lambda: self.localOS.system('cls'),
            2: lambda: self.localOS.system('clear'),
            3: lambda: print("\033[2J\033[3J\033[H", end=''),
            4: lambda: ln(100),
        }

        
    def _InternalAutoClearConfig(self)->None:
        
        
        
        try:
            if (self.localOS.name == 'nt'):
                
                #ansi compatible check
                if (self.localSY.stdout.isatty()):
                    self.clearMode=3
                    #enable ansi
                    kernel32 = self.localCT.windll.kernel32
                    handle = kernel32.GetStdHandle(-11)
                    mode = self.localCT.c_uint32()
                    if kernel32.GetConsoleMode(handle, self.localCT.byref(mode)):
                        kernel32.SetConsoleMode(handle, mode.value | 0x0004)
                    #clear
                    print("\033[2J\033[3J\033[H", end='')
                    
                
                

                #determine what else we could be talking to   
                else:
                
                
                    isTerminal=False
                    try:
                        kernel32 = self.localCT.windll.kernel32
                        h = kernel32.GetStdHandle(-11)  # STD_OUTPUT_HANDLE
                        mode = self.localCT.c_ulong()
                        isTerminal= bool(kernel32.GetConsoleMode(h, self.localCT.byref(mode)))
                    except Exception:
                        isTerminal=False
                    if(isTerminal):
                        self.clearMode=4
                        self.localOS.system('cls')
                        self.clearMode=1
                    else:
                        self.clearMode=5
                        ln(100)
                        self.clearMode=4
                    
                    
                
                

            elif(self.localOS.name == 'posix'):
                self.clearMode=5
                if (self.localSY.stdout.isatty()):
                    term = self.localOS.environ.get('TERM', '')
                    if (term == 'dumb'):
                        self.clearMode=4
                        self.localOS.system('clear')
                        
                        self.clearMode=2
                    elif(not term):
                        self.clearMode=5
                        ln(100)
                        self.clearMode=4
                    else:
                        self.clearMode=3
                        print("\033[2J\033[3J\033[H", end='')
                        

                        

                else:
                    self.clearMode=4
                    ln(100)
                
            else:
                self.clearMode=4
                ln(100)


        except:
            if(self.clearMode==5):
                raise Exception("critical system error: easy cli fallback clear method failed to run!")
            self.clearMode=4
            ln(100)
        


    def clear(self):
        #this is what is usually called. notice how small it is? that means its faster than init!   
        clearOp = self._clearOperationDispatcher.get(self.clearMode)
        if(clearOp is None):
            raise Exception("critical error: clear mode set to invalid value!\nvalue: "+str(self.clearMode))
        else:
            clearOp()
            

    

    def reDetermineTerminalClearType(self):
        self._InternalAutoClearConfig()
    
_PrivateClearHandlerObject=_ClearHandler()




#y value zero index is current y, x value zero index is leftmost collumn. there isnt any protection if the screen isnt tall enough. do not enter ansi strings, it breaks things
def overwriteStringAtPos(yRelativeToCursor:int,absoluteXPos:int,text:str):
    if(not _PrivateAnsiCapableHandlerObject.getAnsiCapable()):
        raise Exception("error: this function requires an ANSI compliant terminal. \nthe current terminal has been determined to not be ANSI compliant.")


    #uses ansi escape codes

    #safety checks
    if(yRelativeToCursor<0):
        raise ValueError("error: y value argument must be a positive integer!\ngiven y value: "+str(yRelativeToCursor))

    if(absoluteXPos<0):
        raise ValueError("error: x value argument must be a positive integer!\ngiven x value: "+str(absoluteXPos))

    if(chr(27) in set(text)): # type: ignore
        raise ValueError("ANSI escape sequences are not allowed in text.")

    #ansi and tuple and strings? oh my!
    #in all seriouslness this is just an ansi escape code mess, in a tuple with our values so we can use a more readable 
    #format without string concat losses, thanks to the join call on that empty string. aka: SHENANIGANS!
    message="".join(("\x1b[?25l\x1b[s\x1b[", str(yRelativeToCursor),"A\x1b[",str(absoluteXPos+1), "G",text,"\x1b[u\x1b[?25h"))
    
    #print that mess
    
    print(message, end='')



#ui header function to save time
def uiHeader():
    _PrivateClearHandlerObject.clear()
    
    if((isinstance(_currentLoadedUIHeaderDoNotEdit, UIHeaderClass))):
        _currentLoadedUIHeaderDoNotEdit.drawUIHeader()
    elif(type(_currentLoadedUIHeaderDoNotEdit)==None):
        raise ValueError("error: no ui header has been set! one must be set before drawing the header!")
    else:
        raise ValueError("error: loaded ui header is not of a compatible type. type must be a child class of UIHeaderClass.\nclass of loaded ui header: "+str(type(_currentLoadedUIHeaderDoNotEdit)))



#literally just an error for the timer so it has its own
class EasyCLIFastPrintThreadError(Exception):
    def __init__(self, message="generic fast print error"):
        self.message = message
        super().__init__(self.message)





class _PrivateInternalAsyncWriterThread(_privateInternalReferenceKeeperObjDoNotEdit.getThreading().Thread):
    def __init__(self):
        super().__init__(daemon=True)
        self._alive=True
        self._printQueue=_privateInternalReferenceKeeperObjDoNotEdit.getQueue().Queue()
        #false means stopping, true means not stopping, i know its confusing, but this is an optimization
        self._stopping=True
        self._stopped=False
        self._working=False
        self._dispatcher = {
            0: self._executeAsyncPrint,
            1: self._executeAsyncClear,
            2: self._executeAsyncuiHeader,
            3: self._executeAsyncOverwriteStringAtPos,
            4: self._executeAsyncStop,
        }
        self.timeRef=_privateInternalGetTimeRef()
        
        self._cycleDuration=0.008
        self.start()  
        _privateInternalGetAtExitRef().register(self.stop)

    def _executeAsyncPrint(self, arguments:tuple):
        args, kwargs = arguments
        print(*args, **kwargs)

    def _executeAsyncuiHeader(self, arguments:tuple):
        args, kwargs = arguments
        uiHeader(*args, **kwargs)

    def _executeAsyncClear(self, arguments=None):
        _PrivateClearHandlerObject.clear()

    def _executeAsyncOverwriteStringAtPos(self,arguments:tuple):
        x,y,text=arguments
        overwriteStringAtPos(y,x,text)

    def _executeAsyncStop(self, arguments=None):
        self._alive=False


    def run(self):
        dispatcher=self._dispatcher
        #because the pain of multithreaded error propagation
        try:
            #init our vars here for speed
            item=None
            start=0
            currentTime=0
            while(self._alive):
                item=self._printQueue.get()

                self._working=True
                start=self.timeRef.perf_counter()
                if(self._stopping):
                    handler = dispatcher.get(item[0])

                    if handler is None:
                        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint internal variables altered externally")
                    
                    handler(item[1])
                currentTime=self.timeRef.perf_counter()
                self._cycleDuration = max(0.005,self._cycleDuration * 0.8 + (currentTime-start) * 0.2)
                self._working=False
    
            self._stopped=True
        
        except Exception as e:
            import traceback
            import sys
            print("Exception in fast writer worker thread:")
            traceback.print_exc()
            print(e)
            sys.exit(1)


        

    def addItemToQueue(self,*args, **kwargs):
        self._printQueue.put_nowait((0,(args,kwargs)))


    def addMultipleItemsToQueue(self,items):
        for item in items:
            self._printQueue.put_nowait((0,item))
    
    def addClearToQueue(self):
        self._printQueue.put_nowait((1,None))

    def addOverwriteStringAtPosToQueue(self,x,y,text):
        self._printQueue.put_nowait((3,(x,y,text)))

    def addUIHeaderToQueue(self,*args,**kwargs):
        self._printQueue.put_nowait((2,(args,kwargs)))

    def stop(self):
        self._stopping=False
        self._alive=False
        self._printQueue.put_nowait((4,None))
        self._working=False
        self.join(timeout=15)
    
    def getIsStoppedOrStopping(self):
        return (self._stopped or (not self._stopping))

    def isBusy(self):
        #i love that the function name is a pun
        #if the queue is empty and we arent printing
        return ((self._printQueue.qsize()>0) or self._working)
    
    def _getWaitTime(self):
        return self._cycleDuration






_PrivateInternalAsyncWriterThreadOBJDoNotEdit=_PrivateInternalAsyncWriterThread()








  
def fastPrint(*args, **kwargs):
    #safety checks
    if(_PrivateInternalAsyncWriterThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncWriterThreadOBJDoNotEdit)!=_PrivateInternalAsyncWriterThread):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncWriterThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is stopped")
    #add a print command to the queue
    _PrivateInternalAsyncWriterThreadOBJDoNotEdit.addItemToQueue(*args, **kwargs)

def fastPrintList(printList):
    #just a wad of safety checks
    if(_PrivateInternalAsyncWriterThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncWriterThreadOBJDoNotEdit)!=_PrivateInternalAsyncWriterThread):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncWriterThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is stopped")
    #add a whole list of tuples of prints to the queue
    _PrivateInternalAsyncWriterThreadOBJDoNotEdit.addMultipleItemsToQueue(printList)

def fastln(number:int=1):
    #it adds the entered numbered of lns to the queue, its not complecated, most of this is just safety checks
    if(type(number)!=int):
        raise ValueError("error: argument must be an integer")
    elif(number<=0):
        raise ValueError("error: argument must be greater than zero")
    elif(number>0):
        fastPrint("\n"*(number),end="")
    else:
        raise ValueError("error: argument somehow hit the no match case, even though that should be impossible. \n(what the heck did you feed this poor function?) \nproblem argument value: "+str(number)+" problem argument value's type: "+str(type(number)))
    

def fastClear():
    #just a wad of safety checks
    if(_PrivateInternalAsyncWriterThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncWriterThreadOBJDoNotEdit)!=_PrivateInternalAsyncWriterThread):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncWriterThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is stopped")
    #add a screen clear to the queue
    _PrivateInternalAsyncWriterThreadOBJDoNotEdit.addClearToQueue()

def fastUIHeader(*args,**kwargs):
    #just a wad of safety checks
    if(_PrivateInternalAsyncWriterThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncWriterThreadOBJDoNotEdit)!=_PrivateInternalAsyncWriterThread):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncWriterThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is stopped")
    #add a header print to the queue, but be warned, it cant return anything
    _PrivateInternalAsyncWriterThreadOBJDoNotEdit.addUIHeaderToQueue(*args,**kwargs)

def fastOverwriteStringAtPos(yRelativeToCursor:int,absoluteXPos:int,text:str):
    #just a wad of safety checks
    if(_PrivateInternalAsyncWriterThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncWriterThreadOBJDoNotEdit)!=_PrivateInternalAsyncWriterThread):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncWriterThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is stopped")
    #add an overwrite command to the queue
    _PrivateInternalAsyncWriterThreadOBJDoNotEdit.addOverwriteStringAtPosToQueue(absoluteXPos,yRelativeToCursor,text)    


def isFastWriterDone():#BE EXTREMELY CAREFUL WITH THIS IT CAN CAUSE A LOCKUP EASILY
    #just a wad of safety checks
    if(_PrivateInternalAsyncWriterThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncWriterThreadOBJDoNotEdit)!=_PrivateInternalAsyncWriterThread):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncWriterThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is stopped")
    
    #is the writer not busy
    return (not _PrivateInternalAsyncWriterThreadOBJDoNotEdit.isBusy())

#use this for synchronization, but be extremely careful with it
def waitForFastWriterFinish(timeoutMS=None,shouldRaiseException:bool=True):#BE EXTREMELY CAREFUL WITH THIS IT CAN CAUSE A LOCKUP EASILY
    #variable we use to keep looping
    waitTime=_PrivateInternalAsyncWriterThreadOBJDoNotEdit._getWaitTime()
    timeref=_privateInternalGetTimeRef()
    waiting=True
    
    if((timeoutMS is None)or((not((type(timeoutMS)==float)or(type(timeoutMS)==int)))and(timeoutMS<=0))):
        #self explanatory
        while waiting:
            
            #just a wad of safety checks
            if(_PrivateInternalAsyncWriterThreadOBJDoNotEdit is None):
                raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
            elif(type(_PrivateInternalAsyncWriterThreadOBJDoNotEdit)!=_PrivateInternalAsyncWriterThread):
                raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
            elif(_PrivateInternalAsyncWriterThreadOBJDoNotEdit.getIsStoppedOrStopping()):
                raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is stopped")
            
            #sleep to deprioritize the main thread and give the printer thread resources to work with
            timeref.sleep(waitTime)
            #check if the writer is done yet
            waiting=_PrivateInternalAsyncWriterThreadOBJDoNotEdit.isBusy()
            waitTime=_PrivateInternalAsyncWriterThreadOBJDoNotEdit._getWaitTime()


    elif((not(timeoutMS is None))and((type(timeoutMS)==float)or(type(timeoutMS)==int))and(timeoutMS>0)):
        #grab a reference to the time standard lib
        
        #grab the current time
        start=timeref.perf_counter()
        
        #self explanatory
        while waiting:
            
            #just a wad of safety checks
            if(_PrivateInternalAsyncWriterThreadOBJDoNotEdit is None):
                raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
            elif(type(_PrivateInternalAsyncWriterThreadOBJDoNotEdit)!=_PrivateInternalAsyncWriterThread):
                raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
            elif(_PrivateInternalAsyncWriterThreadOBJDoNotEdit.getIsStoppedOrStopping()):
                raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is stopped")
            #sleep to deprioritize the main thread and give the printer thread resources to work with
            timeref.sleep(waitTime)
            #check if the writer is done yet
            waiting=_PrivateInternalAsyncWriterThreadOBJDoNotEdit.isBusy()
            #if not calculate how much time has passed, and if it is longer than our timeout
            if((timeref.perf_counter()-start)>timeoutMS):
                if(shouldRaiseException):
                    raise EasyCLIFastPrintThreadError("easyCLI error: fast writer wait timeout exceeded")
                else:
                    waiting=False
                    break
            waitTime=_PrivateInternalAsyncWriterThreadOBJDoNotEdit._getWaitTime()
            
    else:
        raise TypeError("error: timeout is not of supported type of int float or None. type of timeout: "+str(type(timeoutMS)))


    