'''
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. 
'''

# variables and configs we dont want touched


class __InternalPrivateLibReferenceKeeper__:
    def __init__(self) -> None:
        import sys
        import os
        import ctypes
        self.sysLibReference=sys
        self.osLibReference=os
        self.ctypeLibreference=ctypes

    def getSYS(self):
        return self.sysLibReference
    
    def getOS(self):
        return self.osLibReference
    
    def getCTYPES(self):
        return self.ctypeLibreference
    
__privateInternalReferenceKeeperObjDoNotEdit__=__InternalPrivateLibReferenceKeeper__()


def __privateInternalGetSYSRef__():
    return __privateInternalReferenceKeeperObjDoNotEdit__.getSYS()



def __privateInternalGetOSRef__():
    return __privateInternalReferenceKeeperObjDoNotEdit__.getOS()



def __privateInternalGetCTYPESRef__():
    return __privateInternalReferenceKeeperObjDoNotEdit__.getCTYPES()








def ln(number:int=1):
    
    if(type(number)!=int):
        raise ValueError("error: argument must be an integer")
    elif(number<=0):
        raise ValueError("error: argument must be greater than zero")
    elif(number>0):
        print("\n"*(number),end="")
    else:
        raise ValueError("error: argument somehow hit the no match case, even though that should be impossible. \n(what the heck did you feed this poor function?) \nproblem argument value: "+str(number)+" problem argument value's type: "+str(type(number)))


def warning()->str:
    warning="do not edit this file durring runtime, it runs critical backend systems of easy cli, \nand messing with it can have extremely serious consequences, often resulting in crashing \nor unitended behavour. it is strongly encouraged to leave this file alone if you do not\n know what you are doing."
    print(warning)
    return warning





class UIHeaderClass:
    def __init__(self,currentScreenName:str|None):
        self.currentScreenName:str|None=currentScreenName
        

    def setCurrentScreenName(self,newName:str):
        self.currentScreenName=newName

    def getCurrentScreenName(self):
        return self.currentScreenName

    def drawUIHeader(self):
        pass

__currentLoadedUIHeaderDoNotEdit__:UIHeaderClass|None=None

class __CheckAnsiCapableHandler__:
    def __internalCheckAnsiCapable__(self)->bool:
        localC=__privateInternalGetCTYPESRef__()
        localO=__privateInternalGetOSRef__()
        localS=__privateInternalGetSYSRef__()
        tempAnsiCapable:bool=False
        try:
            if (localO.name == 'nt'):
                if (localS.stdout.isatty()):
                    #enable ansi
                    kernel32 = localC.windll.kernel32
                    handle = kernel32.GetStdHandle(-11)
                    mode = localC.c_uint32()
                    if kernel32.GetConsoleMode(handle, localC.byref(mode)):
                        kernel32.SetConsoleMode(handle, mode.value | 0x0004)
                    #clear
                    tempAnsiCapable=True

            elif(localO.name == 'posix'):
                if localS.stdout.isatty():
                    term = localO.environ.get('TERM', '')
                    if((not term) or (term == 'dumb')):
                        tempAnsiCapable=False
                    else:
                        tempAnsiCapable=True

            else:
                tempAnsiCapable=False
        except:
            tempAnsiCapable=False

        return tempAnsiCapable

        
    def __init__(self)->None:
        #this whole thing just runs that check
        self.ansiCapable:bool=False
        self.ansiCapable=self.__internalCheckAnsiCapable__()
        if(type(self.ansiCapable)!=bool):
            raise RuntimeError("error: how the heck did this trigger? it should be physically impossible! \nthere should be no way for those variables to not be set at this point! \nwell, hopefully restarting the program can fix it for you.\n "+" type of ansiCapable: "+ str(type(self.ansiCapable))+" value of ansiCapable: "+str(self.ansiCapable))

    def recheckAnsiCapable(self)->None:
        self.ansiCapable=self.__internalCheckAnsiCapable__()

    
    def getAnsiCapable(self)->bool:
        return self.ansiCapable
        
    
    
__PrivateAnsiCapableHandlerObject__=__CheckAnsiCapableHandler__()
    


class __ClearHandler__:
    def __init__(self) -> None:
        self.localCT=__privateInternalGetCTYPESRef__()
        self.localSY=__privateInternalGetSYSRef__()
        self.localOS=__privateInternalGetOSRef__()
        self.clearMode:int=0

        
    def __InternalAutoClearConfig__(self)->None:
        
        
        
        try:
            
            if (self.localOS.name == 'nt'):
                
                #ansi compatible check
                if (self.localSY.stdout.isatty()):
                    self.clearMode=3
                    #enable ansi
                    kernel32 = self.localCT.windll.kernel32
                    handle = kernel32.GetStdHandle(-11)
                    mode = self.localCT.c_uint32()
                    if kernel32.GetConsoleMode(handle, self.localCT.byref(mode)):
                        kernel32.SetConsoleMode(handle, mode.value | 0x0004)
                    #clear
                    print("\033[2J\033[3J\033[H", end='')
                    
                
                

                #determine what else we could be talking to   
                else:
                
                
                    isterminternal=False
                    try:
                        kernel32 = self.localCT.windll.kernel32
                        h = kernel32.GetStdHandle(-11)  # STD_OUTPUT_HANDLE
                        mode = self.localCT.c_ulong()
                        isterminternal= bool(kernel32.GetConsoleMode(h, self.localCT.byref(mode)))
                    except Exception:
                        isterminternal=False
                    if(isterminternal):
                        self.clearMode=4
                        self.localOS.system('cls')
                        self.clearMode=1
                    else:
                        self.clearMode=5
                        ln(100)
                        self.clearMode=4
                    
                    
                
                

            elif(self.localOS.name == 'posix'):
                self.clearMode=5
                if (self.localSY.stdout.isatty()):
                    term = self.localOS.environ.get('TERM', '')
                    if (term == 'dumb'):
                        self.clearMode=4
                        self.localOS.system('clear')
                        
                        self.clearMode=2
                    elif(not term):
                        self.clearMode=5
                        ln(100)
                        self.clearMode=4
                    else:
                        self.clearMode=3
                        print("\033[2J\033[3J\033[H", end='')
                        

                        

                else:
                    self.clearMode=4
                    ln(100)
                
            else:
                self.clearMode=4
                ln(100)


        except:
            if(self.clearMode==5):
                raise Exception("critical system error: easy cli fallback clear method failed to run!")
            self.clearMode=4
            ln(100)
        


    def clear(self):
        #this is what is usually called. notice how small it is? that means its faster than init!   
        if(self.clearMode==1):
            self.localOS.system('cls')
        elif(self.clearMode==2):
            self.localOS.system('clear')
        elif(self.clearMode==3):
            print("\033[2J\033[3J\033[H", end='')
        elif(self.clearMode==4):
            ln(100)
        elif(self.clearMode==0):
            self.__InternalAutoClearConfig__()
            

        else:
            raise Exception("critical error: clear mode set to invalid value!\nvalue: "+str(self.clearMode))
        
    def reDetermineTerminalClearType(self):
        self.__InternalAutoClearConfig__()
    
__PrivateClearHandlerObject__=__ClearHandler__()