'''
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. 
'''

# variables and configs we dont want touched


class _InternalPrivateLibReferenceKeeper:
    def __init__(self) -> None:
        import sys
        import os
        import ctypes
        import threading
        import queue
        import atexit
        self.sysLibReference=sys
        self.osLibReference=os
        self.ctypeLibreference=ctypes
        self.threadingLibReference=threading
        self.queueLibReference=queue
        self.atexitLibReference=atexit

    def getSYS(self):
        return self.sysLibReference
    
    def getOS(self):
        return self.osLibReference
    
    def getCTypes(self):
        return self.ctypeLibreference
    
    def getThreading(self):
        return self.threadingLibReference
    
    def getQueue(self):
        return self.queueLibReference
    
    def getAtExit(self):
        return self.atexitLibReference
    
_privateInternalReferenceKeeperObjDoNotEdit=_InternalPrivateLibReferenceKeeper()


def _privateInternalGetSYSRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getSYS()



def _privateInternalGetOSRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getOS()



def _privateInternalGetCTypesRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getCTypes()

def _privateInternalGetThreadingRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getThreading()

def _privateInternalGetQueueRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getQueue()

def _privateInternalGetAtExitRef():
    return _privateInternalReferenceKeeperObjDoNotEdit.getAtExit()





    

    





def ln(number:int=1):
    
    if(type(number)!=int):
        raise ValueError("error: argument must be an integer")
    elif(number<=0):
        raise ValueError("error: argument must be greater than zero")
    elif(number>0):
        print("\n"*(number),end="")
    else:
        raise ValueError("error: argument somehow hit the no match case, even though that should be impossible. \n(what the heck did you feed this poor function?) \nproblem argument value: "+str(number)+" problem argument value's type: "+str(type(number)))





def warning()->str:
    warning="do not edit this file durring runtime, it runs critical backend systems of easy cli, \nand messing with it can have extremely serious consequences, often resulting in crashing \nor unitended behavour. it is strongly encouraged to leave this file alone if you do not\n know what you are doing."
    print(warning)
    return warning





class UIHeaderClass:
    def __init__(self,currentScreenName:str|None):
        self.currentScreenName:str|None=currentScreenName
        

    def setCurrentScreenName(self,newName:str):
        self.currentScreenName=newName

    def getCurrentScreenName(self):
        return self.currentScreenName

    def drawUIHeader(self):
        #DO NOT USE FASTCLI FUNCTIONS IN UI HEADER, AS THAT CAN CAUSE RACE CONDITIONS
        pass

_currentLoadedUIHeaderDoNotEdit:UIHeaderClass|None=None

class _CheckAnsiCapableHandler:
    def internalCheckAnsiCapable(self)->bool:
        localC=_privateInternalGetCTypesRef()
        localO=_privateInternalGetOSRef()
        localS=_privateInternalGetSYSRef()
        tempAnsiCapable:bool=False
        try:
            if (localO.name == 'nt'):
                if (localS.stdout.isatty()):
                    #enable ansi
                    kernel32 = localC.windll.kernel32
                    handle = kernel32.GetStdHandle(-11)
                    mode = localC.c_uint32()
                    if kernel32.GetConsoleMode(handle, localC.byref(mode)):
                        kernel32.SetConsoleMode(handle, mode.value | 0x0004)
                    #clear
                    tempAnsiCapable=True

            elif(localO.name == 'posix'):
                if localS.stdout.isatty():
                    term = localO.environ.get('TERM', '')
                    if((not term) or (term == 'dumb')):
                        tempAnsiCapable=False
                    else:
                        tempAnsiCapable=True

            else:
                tempAnsiCapable=False
        except:
            tempAnsiCapable=False

        return tempAnsiCapable

        
    def __init__(self)->None:
        #this whole thing just runs that check
        self.ansiCapable:bool=False
        self.ansiCapable=self.internalCheckAnsiCapable()
        if(type(self.ansiCapable)!=bool):
            raise RuntimeError("error: how the heck did this trigger? it should be physically impossible! \nthere should be no way for those variables to not be set at this point! \nwell, hopefully restarting the program can fix it for you.\n "+" type of ansiCapable: "+ str(type(self.ansiCapable))+" value of ansiCapable: "+str(self.ansiCapable))

    def recheckAnsiCapable(self)->None:
        self.ansiCapable=self.internalCheckAnsiCapable()

    
    def getAnsiCapable(self)->bool:
        return self.ansiCapable
        
    
    
_PrivateAnsiCapableHandlerObject=_CheckAnsiCapableHandler()
    


class _ClearHandler:
    def __init__(self) -> None:
        self.localCT=_privateInternalGetCTypesRef()
        self.localSY=_privateInternalGetSYSRef()
        self.localOS=_privateInternalGetOSRef()
        self.clearMode:int=0

        
    def _InternalAutoClearConfig(self)->None:
        
        
        
        try:
            
            if (self.localOS.name == 'nt'):
                
                #ansi compatible check
                if (self.localSY.stdout.isatty()):
                    self.clearMode=3
                    #enable ansi
                    kernel32 = self.localCT.windll.kernel32
                    handle = kernel32.GetStdHandle(-11)
                    mode = self.localCT.c_uint32()
                    if kernel32.GetConsoleMode(handle, self.localCT.byref(mode)):
                        kernel32.SetConsoleMode(handle, mode.value | 0x0004)
                    #clear
                    print("\033[2J\033[3J\033[H", end='')
                    
                
                

                #determine what else we could be talking to   
                else:
                
                
                    isterminternal=False
                    try:
                        kernel32 = self.localCT.windll.kernel32
                        h = kernel32.GetStdHandle(-11)  # STD_OUTPUT_HANDLE
                        mode = self.localCT.c_ulong()
                        isterminternal= bool(kernel32.GetConsoleMode(h, self.localCT.byref(mode)))
                    except Exception:
                        isterminternal=False
                    if(isterminternal):
                        self.clearMode=4
                        self.localOS.system('cls')
                        self.clearMode=1
                    else:
                        self.clearMode=5
                        ln(100)
                        self.clearMode=4
                    
                    
                
                

            elif(self.localOS.name == 'posix'):
                self.clearMode=5
                if (self.localSY.stdout.isatty()):
                    term = self.localOS.environ.get('TERM', '')
                    if (term == 'dumb'):
                        self.clearMode=4
                        self.localOS.system('clear')
                        
                        self.clearMode=2
                    elif(not term):
                        self.clearMode=5
                        ln(100)
                        self.clearMode=4
                    else:
                        self.clearMode=3
                        print("\033[2J\033[3J\033[H", end='')
                        

                        

                else:
                    self.clearMode=4
                    ln(100)
                
            else:
                self.clearMode=4
                ln(100)


        except:
            if(self.clearMode==5):
                raise Exception("critical system error: easy cli fallback clear method failed to run!")
            self.clearMode=4
            ln(100)
        


    def clear(self):
        #this is what is usually called. notice how small it is? that means its faster than init!   
        if(self.clearMode==1):
            self.localOS.system('cls')
        elif(self.clearMode==2):
            self.localOS.system('clear')
        elif(self.clearMode==3):
            print("\033[2J\033[3J\033[H", end='')
        elif(self.clearMode==4):
            ln(100)
        elif(self.clearMode==0):
            self._InternalAutoClearConfig()
            

        else:
            raise Exception("critical error: clear mode set to invalid value!\nvalue: "+str(self.clearMode))

    

    def reDetermineTerminalClearType(self):
        self._InternalAutoClearConfig()
    
_PrivateClearHandlerObject=_ClearHandler()




#y value zero index is current y, x value zero index is leftmost collumn. there isnt any protection if the screen isnt tall enough. do not enter ansi strings, it breaks things
def overwriteStringAtPos(yRelativeToCursor:int,absoluteXPos:int,text:str):
    if(not _PrivateAnsiCapableHandlerObject.getAnsiCapable()):
        raise Exception("error: this function requires an ANSI compliant terminal. \nthe current terminal has been determined to not be ANSI compliant.")


    #uses ansi escape codes

    #safety checks
    if(yRelativeToCursor<0):
        raise ValueError("error: y value argument must be a positive integer!\ngiven y value: "+str(yRelativeToCursor))

    if(absoluteXPos<0):
        raise ValueError("error: x value argument must be a positive integer!\ngiven x value: "+str(absoluteXPos))

    if(chr(27) in set(text)): # type: ignore
        raise ValueError("ANSI escape sequences are not allowed in text.")

    #ansi and tuple and strings? oh my!
    #in all seriouslness this is just an ansi escape code mess, in a tuple with our values so we can use a more readable 
    #format without string concat losses, thanks to the join call on that empty string. aka: SHENANIGANS!
    message="".join(("\x1b[?25l\x1b[s\x1b[", str(yRelativeToCursor),"A\x1b[",str(absoluteXPos+1), "G",text,"\x1b[u\x1b[?25h"))
    
    #print that mess
    
    print(message, end='')



#ui header function to save time
def uiHeader():
    _PrivateClearHandlerObject.clear()
    
    if((isinstance(_currentLoadedUIHeaderDoNotEdit, UIHeaderClass))):
        _currentLoadedUIHeaderDoNotEdit.drawUIHeader()
    elif(type(_currentLoadedUIHeaderDoNotEdit)==None):
        raise ValueError("error: no ui header has been set! one must be set before drawing the header!")
    else:
        raise ValueError("error: loaded ui header is not of a compatible type. type must be a child class of UIHeaderClass.\nclass of loaded ui header: "+str(type(_currentLoadedUIHeaderDoNotEdit)))



#literally just an error for the timer so it has its own
class EasyCLIFastPrintThreadError(Exception):
    def __init__(self, message="generic fast print error"):
        self.message = message
        super().__init__(self.message)





class __PrivateInternalAsyncPrintThread(_privateInternalReferenceKeeperObjDoNotEdit.getThreading().Thread):
    def __init__(self):
        super().__init__(daemon=True)
        self._alive=True
        self._printQueue=_privateInternalReferenceKeeperObjDoNotEdit.getQueue().Queue()
        self._stopping=False
        self._stopped=False
        self._working=False
        self.start()  
        _privateInternalGetAtExitRef().register(self.stop)


    def run(self):
        '''
        _PRINT = 0
        _CLEAR = 1
        _UI_HEADER = 2
        _OVERWRITE = 3
        _EXIT = 4
        '''
        try:
            item=()

            while(self._alive):
                item=self._printQueue.get()
                self._working=True
                if(not(self._stopping)):
                    if(item[0]==0):
                        args, kwargs = item[1]
                        print(*args, **kwargs)
                    elif(item[0]==1):
                        _PrivateClearHandlerObject.clear()
                    elif(item[0]==2):
                        uiHeader()
                    elif(item[0]==3):
                        x,y,text=item[1]
                        overwriteStringAtPos(y,x,text)
                    elif(item[0]==4):
                        self._alive=False
                        break
                    else:
                        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint internal variables altered externally")
                self._working=False
    
            self._stopped=True
        
        except Exception:
            import traceback
            import os
            print("Exception in fast cli Worker thread:")
            traceback.print_exc()
            os._exit(1)
        

    def addItemToQueue(self,*args, **kwargs):
        self._printQueue.put((0,(args,kwargs)))


    def addMultipleItemsToQueue(self,items):
        for item in items:
            self._printQueue.put((0,item))
    
    def addClearToQueue(self):
        self._printQueue.put((1,None))

    def addOverwriteStringAtPosToQueue(self,x,y,text):
        self._printQueue.put((3,(x,y,text)))

    def addUIHeaderToQueue(self):
        self._printQueue.put((2,None))

    def stop(self):
        self._stopping=True
        self._alive=False
        self._printQueue.put((4,None))
        self.working=False
        self.join(timeout=15)
    
    def getIsStoppedOrStopping(self):
        return (self._stopped or self._stopping)

    def isNotBusy(self):
        return ((self._printQueue.qsize()==0) and (not self._working))

_PrivateInternalAsyncPrintThreadOBJDoNotEdit=None
if(__name__=="__main__"):
    __PrivateInternalAsyncPrintThread()
    
def fastPrint(*args, **kwargs):
    if(_PrivateInternalAsyncPrintThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncPrintThreadOBJDoNotEdit)!=_PrivateInternalAsyncPrintThreadOBJDoNotEdit):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncPrintThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    _PrivateInternalAsyncPrintThreadOBJDoNotEdit.addItemToQueue(args, kwargs)

def fastPrintList(printList):
    if(_PrivateInternalAsyncPrintThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncPrintThreadOBJDoNotEdit)!=_PrivateInternalAsyncPrintThreadOBJDoNotEdit):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncPrintThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    _PrivateInternalAsyncPrintThreadOBJDoNotEdit.addMultipleItemsToQueue(printList)

def fastln(number:int=1):
    if(type(number)!=int):
        raise ValueError("error: argument must be an integer")
    elif(number<=0):
        raise ValueError("error: argument must be greater than zero")
    elif(number>0):
        fastPrint("\n"*(number),end="")
    else:
        raise ValueError("error: argument somehow hit the no match case, even though that should be impossible. \n(what the heck did you feed this poor function?) \nproblem argument value: "+str(number)+" problem argument value's type: "+str(type(number)))
    

def fastClear():
    if(_PrivateInternalAsyncPrintThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncPrintThreadOBJDoNotEdit)!=_PrivateInternalAsyncPrintThreadOBJDoNotEdit):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncPrintThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    _PrivateInternalAsyncPrintThreadOBJDoNotEdit.addClearToQueue()

def fastUIHeader():
    if(_PrivateInternalAsyncPrintThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncPrintThreadOBJDoNotEdit)!=_PrivateInternalAsyncPrintThreadOBJDoNotEdit):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncPrintThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    _PrivateInternalAsyncPrintThreadOBJDoNotEdit.addUIHeaderToQueue()

def fastOverwriteStringAtPos(yRelativeToCursor:int,absoluteXPos:int,text:str):
    if(_PrivateInternalAsyncPrintThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncPrintThreadOBJDoNotEdit)!=_PrivateInternalAsyncPrintThreadOBJDoNotEdit):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncPrintThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    _PrivateInternalAsyncPrintThreadOBJDoNotEdit.addOverwriteStringAtPosToQueue(absoluteXPos,yRelativeToCursor,text)    


def isFastPrintDone():#BE EXTREMELY CAREFUL WITH THIS
    if(_PrivateInternalAsyncPrintThreadOBJDoNotEdit is None):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object not found")
    elif(type(_PrivateInternalAsyncPrintThreadOBJDoNotEdit)!=_PrivateInternalAsyncPrintThreadOBJDoNotEdit):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    elif(_PrivateInternalAsyncPrintThreadOBJDoNotEdit.getIsStoppedOrStopping()):
        raise EasyCLIFastPrintThreadError("easyCLI error: fastPrint controller object is not the correct Datatype")
    _PrivateInternalAsyncPrintThreadOBJDoNotEdit.isNotBusy()   
